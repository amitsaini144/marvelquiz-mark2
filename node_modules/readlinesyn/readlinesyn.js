'use strict';  
  
//    
//  Reading file line by line synochronicaly libraries    
//    
//  Author: Chunfeng Yang    
//  All rights reserved.      
//  This software is supplied "AS IS" without any warranties and support.     
//  The author assumes no responsibility or liability for the use of the software,   
//  conveys no license or title under any patent, copyright, or mask work right to the product.    
//  The author reserves the right to make changes in the software without notification.    
//   
//  
//  Date: 2016-06-21  
//       Remove a bug in open function  
//  
//  Date: 2016-09-14  
//       Open the file path as constructor argument  
//  
//  Date: 2019-09-14  
//       Remove a bug => "return self._leftOver;" 
//    
const fs = require('fs');  
  
module.exports = function( path ) {  
    this._encode = "utf8";   
    this._leftOver = "";  
    this._lineEndIndex = "\n"; 
    this._EOF = true;  
    this._filename;  
    this._fd = 0;  
    this._bufferSize = 1024;  
    this._buffer = new Buffer(this._bufferSize);  
  
    this.open = function( thePath )   
    {   
        if( thePath )
        {
            // do nothing 
        } else{
            console.log("open(): Invalid file path");
        }    
        if( typeof thePath == 'undefined' ) {
            console.log("open(): undefined file path");
        }
    
        if( typeof thePath === "" ) {
            console.log("open(): file path is empty");  
        }

        var self = this;  
        self._EOF = true; 

        self._leftOver = new String();  		
		
        self._filename = thePath;    
        try{  
            if(0 !== self._fd)  
            {
                console.log('open(): close old file handle.');
               self.close(); 
               self._fd = 0;			   
            }  		
		
            self._fd = fs.openSync(self._filename, 'r');

            //console.log('open(): open ' + self._filename);
            //console.log('  file handle:' + self._fd);
        }   
        catch ( exception )  
        {  
            console.log( 'open(): ' + self._filename + ' not found.');  
            self._EOF = true;  
            return;  
        }   
		
        self._leftOver = "";
        self._EOF = false;  	
        return;  
    }  
  
   try{  
       if( path != undefined )
	   {
          var tmp = fs.statSync( path ).isFile() ; 
          if(Boolean(tmp) ){
            this.open( path ); 
          }  
	   }
    }   
    catch ( exception )  
    {   
        console.log(exception);  
    }  
  
    this.close = function( )   
    {   
         var self = this;  
         try{  
             fs.closeSync(self._fd);   
         }  
         catch ( exception )  
         {  
              console.log( 'closing file failed.');  
         }  
         self._EOF = true;  
         self._fd = 0;   
         return;  
    }  
    
    this.isEOF = function( )  
    {
        return this._EOF;
    }
  
    this.next = function( )   
    {   
        var self = this;  
  
        if(0 == self._fd)  
        {
            // console.log( 'readlinesyn::next(): Invalid file.'); 
            self._EOF = true; 
             return;  
        }  
  
        var _idxStart = 0;  
        var idx = -1; 
		


        //console.log('readlinesyn::next(): self._leftOver = ' + self._leftOver);
        //console.log("\n");

        if ((idx = self._leftOver.indexOf(self._lineEndIndex, _idxStart)) !== -1) {  
        
            //console.log('readlinesyn::next(): idx = ' + idx);

            idx = idx + 1; 
            var line = self._leftOver.substring(_idxStart, idx);  
            _idxStart = idx ; //+ 1;  
            self._leftOver = self._leftOver.substring(_idxStart);  
		

              //console.log('readlinesyn::next(): line: ' + line);
              //console.log("\n");


            return line;  
          } 		
		  		
        //  		
        if ((idx = self._leftOver.indexOf(self._lineEndIndex, _idxStart)) == -1) {


            //console.log('readlinesyn::next(): idx = ' + idx);


            var read;  
            try{  
                read = fs.readSync(self._fd, self._buffer, 0, self._bufferSize, null);
            }   
            catch ( exception )  
            {  
                console.log('readlinesyn::next(): reading file failed.');
                 self.close();   
                 return;  
            }  
            if (read !== 0) {  
                self._leftOver += self._buffer.toString(self._encode, 0, read);
              return self.next();			  
            } else {

                //console.log('readlinesyn::next(): read characters = ' + read);

                 try{  
                     fs.closeSync(self._fd);  
                  }  
                 catch ( exception )  
                 {  
                    console.log( 'closing file failed.');  
                 }
                 // console.log('readlinesyn::next(): reaching file END.');
                 self._EOF = true;  
                 self._fd = 0; 
                 return self._leftOver; 
            }  
         }  
    }
    
  // interger number format output 
  this.str2FormateStr = function( str, strlen ){
    // checking value 
    if(  undefined == str ) {
        console.error("readlinesyn::str2FormateStr: Invalid str");
        return;
      }  
      
      var len = str.length;
      if( len == strlen ){
          return str;
      }
      if( len > strlen ){
        return str.slice( strlen );
      }
      var spaceLen = strlen - len;
      var arr = new Array(parseInt(spaceLen)+1 ); 
      var spaceStr = arr.join(" ");    
      //var spaceStr = str.slice(0, spaceLen-1 );   
      return spaceStr.concat(tmpStr);
  }

    // interger number format output 
  this.int2FormateStr = function (value, strlen) {
      // checking value 
      if ((undefined == value) || (isNaN(value))) {
          console.error("readlinesyn::int2FormateStr: Invalid value");
          return;
      }
      // Checking strlen 
      if (parseInt(strlen) > 1024) {
          console.error("readlinesyn::int2FormateStr: Too large string length");
          return;
      }

      var tmpStr = (parseInt(value)).toString();
      var len = tmpStr.length;

      var spaceLen = strlen - len;
      if (spaceLen == 0) {
          return tmpStr;
      }
      if (spaceLen < 0) {
          console.error("readlinesyn::int2FormateStr: small string length");
          return tmpStr;
      }
      var arr = new Array(parseInt(spaceLen) + 1);
      var spaceStr = arr.join(" ");
      return spaceStr.concat(tmpStr);
  }

    // float number format output 
    // float2FormateStr( 123.5, 10, 2)
    //
  this.float2FormateStr = function (value, strlen, fixedNum) {
      // checking value 
      if ((undefined == value) || (isNaN(value))) {
          console.error("readlinesyn::float2FormateStr: Invalid value");
          return;
      }
      // checking fixedNum
      if ((undefined == fixedNum) || (isNaN(fixedNum))) {
          console.error("readlinesyn::float2FormateStr: Invalid value");
          return;
      }
      // Checking strlen 
      if (parseInt(strlen) > 1024) {
          console.error("readlinesyn::float2FormateStr: Too large string length");
          return;
      }
      //var str = "                                              ";
      var tmpStr = (parseFloat(value)).toFixed(fixedNum);
      var len = tmpStr.length;

      var spaceLen = strlen - len;
      if (spaceLen == 0) {
          return tmpStr;
      }
      if (spaceLen < 0) {
          tmpStr = parseFloat(value).toExponential(1);
          if ((strlen - tmpStr.length) == 0) {
              return tmpStr;
          }
          if ((strlen - tmpStr.length) < 0) {
              console.error("readlinesyn::float2FormateStr: small string length");
              return tmpStr;
          }
          spaceLen = (strlen - tmpStr.length);
      }
      var arr = new Array(parseInt(spaceLen) + 1);
      var spaceStr = arr.join(" ");
      return spaceStr.concat(tmpStr);
  }
}  
